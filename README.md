<h1>Thread Creation Approaches in Java</h1>

<h2>1st Approach: Extending Thread</h2>
    <p>
        <strong>myThread</strong> extends <strong>Thread</strong> and optionally implements <strong>Runnable</strong>
    </p>

<h2>2nd Approach: Implementing Runnable</h2>
    <p>
        <strong>myRunnable</strong> implements <strong>Runnable</strong> interface.
    </p>

<p>
        The <code>Runnable</code> interface is present in the <code>java.lang</code> package and contains only one method: <code>run()</code>
    </p>

<h2>Case Study</h2>

<pre>
    MyRunnable r = new MyRunnable();
    Thread t1 = new Thread();
    Thread t2 = new Thread(r);
    </pre>

<h3>Case 1: <code>t1.start();</code></h3>
    <p>
        A new thread will be created and will execute the <code>Thread</code> class's <code>run()</code> method, which has an empty implementation.
    </p>

<h3>Case 2: <code>t1.run();</code></h3>
    <p>
        No new thread will be created. The <code>Thread</code> class's <code>run()</code> method will be executed just like a normal method call.
    </p>

<h3>Case 3: <code>t2.start();</code></h3>
    <p>
        A new thread will be created, and it will execute the <code>run()</code> method of the <code>MyRunnable</code> class.
    </p>

<h3>Case 4: <code>t2.run();</code></h3>
    <p>
        No new thread will be created. The <code>MyRunnable</code> class's <code>run()</code> method will be executed like a normal method call.
    </p>

<h3>Case 5: <code>r.start();</code></h3>
    <p>
        This will result in a compile-time error: <code>MyRunnable</code> does not have <code>start()</code> capability.
        <br>
        <strong>Error:</strong> cannot find symbol <br>
        <strong>Symbol:</strong> method start() <br>
        <strong>Location:</strong> class MyRunnable
    </p>

<h3>Case 6: <code>r.run();</code></h3>
    <p>
        No new thread will be created, and the <code>MyRunnable</code> class's <code>run()</code> method will be executed like a normal method call.
    </p>

<h2>Which Approach is Best?</h2>
    <p>
        Among the two ways of defining a thread, <strong>implementing the Runnable interface</strong> is the recommended approach.
    </p>
    <ul>
        <li>
            In the first approach (extending Thread), our class already extends the <code>Thread</code> class, so we cannot extend any other class, thus losing the benefits of inheritance.
        </li>
        <li>
            In the second approach (implementing Runnable), since we are only implementing an interface, we can still extend another class and gain inheritance benefits.
        </li>
    </ul>

<h2>Thread Class Constructors</h2>
    <ol>
        <li><code>Thread t = new Thread();</code></li>
        <li><code>Thread t = new Thread(Runnable r);</code></li>
        <li><code>Thread t = new Thread(String name);</code></li>
        <li><code>Thread t = new Thread(Runnable r, String name);</code></li>
        <li><code>Thread t = new Thread(ThreadGroup group, Runnable r);</code></li>
        <li><code>Thread t = new Thread(ThreadGroup group, Runnable r, String name);</code></li>
        <li><code>Thread t = new Thread(ThreadGroup group, String name);</code></li>
        <li><code>Thread t = new Thread(ThreadGroup group, Runnable r, String name, long stackSize);</code></li>
    </ol>

<h4>Getting and Setting Name of thread</h4>
<p>every thread in java it may be generated by JVM and costmizer name by programmer.
 by using following two method of thread class
         <ol>
            <li><i> public final String getName() </i></li>
            <li><i>public final void setName(String threadName)</i></li>
         </ol> </p>

<p><b>Note :</b>we can get current thread object by using Thread.currentThread()</p>

<h4> Thread Priority </h4>
<p>every thread in java has some priority it may be default priority genrated by JVM or coustmizer priority by pogrammer.
the vaild range of priority is  1 to 10 there one is min_priority 10 is max_priority thread class defines the following contents to represent some standard priorities </p>
<ol>
<li>Thread.MIN_PRIORITY -> 1</li>
<li>Thread.NORM_PRIORITY -> 5</li>
<li>Thread.MAX_PRIORITY -> 10</li>
</ol>

<b>Thread schedular will use priorities while allocating processor</b>
<p> The Thread which having highest priority will get the chance first</p>
<p>if thread having same priority then we can't exact execution order it depends on thread schedular</p>
<b>public final int getPriority()</b>
<b>public final void setPriority( int priority)</b>
 <p> priority range 1 to 10
     t.setPriority(7);
     t.setPriority(17);// got exceptions IllegleArugmentException 
     thread class define the following methods to get and set priority of thread
the default priority is 5 but for all remaining therad default priority inherited parent-> child 
that is whatever priority parent thread has same priority there for child thread.
</p>
